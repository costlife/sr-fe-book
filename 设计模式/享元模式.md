### 享元模式（Flyweight）
运行==共享技术==有效地支持大量细粒度的对象，避免大量拥有相同内容的小类的开销(如耗费内存)，使大家共享一个类(元类)。
###### 注：共享的对象必须是不可变的，不然一变则全变（如果有这种需求除外）。

享元模式可以避免大量非常相似类的开销，在程序设计中，有时需要生产大量细粒度的类实例来表示数据，如果能发现这些实例除了几个参数以外，开销基本相同的 话，就可以大幅度较少需要实例化的类的数量。如果能把那些参数移动到类实例的外面，在方法调用的时候将他们传递进来，就可以通过共享大幅度第减少单个实例 的数目。

那么如果在JavaScript中应用享元模式呢？有两种方式，第一种是应用在数据层上，主要是应用在内存里大量相似的对象上；第二种是应用在DOM层上，享元可以用在中央事件管理器上用来避免给父容器里的每个子元素都附加事件句柄。

### 享元与数据层
Flyweight中有两个重要概念--==内部状态intrinsic==和==外部状态extrinsic==之分，内部状态就是在对象里通过内部方法管理，而外部信息可以在通过外部删除或者保存。

说白点,就是先捏一个的原始模型，然后随着不同场合和环境,再产生各具特征的具体模型，很显然,在这里需要产生不同的新对象，所以Flyweight模式中常出现Factory模式，Flyweight的==内部状态是用来共享的==，Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象。
### 使用优缺点
###### 享元模式优点就在于它能够大幅度的降低内存中对象的数量；
###### 而为了做到这一步也带来了它的缺点：它使得系统逻辑复杂化，而且在一定程度上外蕴状态影响了系统的速度。
### 使用享元模式的条件：
###### 1) 系统中有大量的对象，他们使系统的效率降低。

###### 2) 这些对象的状态可以分离出所需要的内外两部分。

    /**
     * 享元模式是一个为了提高性能(空间复杂度)的设计模式
     * 他使用与程序会生产大量的相类似的对象是耗用大量的内存的问题
     */
    (function(){
    	//有一个城市要进行汽车的登记
    	/**
    	 * 制造商
    	 * 型号
    	 * 拥有者
    	 * 车牌号码
    	 * 最近一次登记日期
    	 */
    	var Car = function(make,model,year){
    		this.make = make;
    		this.model = model;
    		this.year = year;
    		this.getMake = function(){
    			return this.make;
    		}
    	}
    	var myCarInfo = function(){
    		this.createCar = function(make,model,year,owner,tag,renewDate){
    			var c = new Car(make,model,year);
    			c["owner"] = owner;
    			c["tag"] = tag;
    			c["renewDate"] = renewDate;
    			return c;
    		}
    	}
    	//北京车两 4150000 全部要登记
    	var test = new myCarInfo();
    	var startDate = new Date().getTime();
    	var ca = new Array();
    	for (var i = 0; i < 4150000; i++) {
    		ca.push(test.createCar("东风","雪铁龙","2018-4-8",
    					"张三","京pcat2145","2017-8-13"))
    	}
    	var endDate = new Date();
    	alert(endDate - startDate);	
    })()


享元模式实际应用不是很多。不过享元模式并不是鸡肋，它的精髓——共享是对我们系统优化非常有好处的，而且这种思想已经别越来越多的应用，这应该就算是享元模式的应用了吧。如果你已经领会到了享元模式的精髓，那么也就是掌握了享元模式了!